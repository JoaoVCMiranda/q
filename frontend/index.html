<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Interactive Wave Study</title>
    <style>
        body {
            margin: 0;
            background-color: #111;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #animation-controls {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #info-display {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: flex-end; /* Right-align content */
            gap: 10px;
        }
        
        #phase-value {
            background: rgba(0,0,0,0.6);
            padding: 8px 12px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 16px;
            color: #00ff88;
        }

        .control-button {
            padding: 12px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .control-button.primary { background-color: #008cff; color: white; }
        .control-button.secondary { background-color: #00ff88; color: #111; }
        .control-button.tertiary { background-color: #ffaa00; color: #111; }
        .control-button.info { background-color: #cccccc; color: #111; font-size: 12px; padding: 6px 12px; }
        .control-button:hover:not(:disabled) { filter: brightness(1.1); }
        .control-button:disabled { background-color: #555; color: #999; cursor: not-allowed; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="animation-controls">
        <button id="translateButton" class="control-button primary">Translate</button>
        <button id="rotateButton" class="control-button secondary">Animate Phase</button>
        <button id="toggleHelixButton" class="control-button tertiary">Toggle 3D Helix</button>
    </div>

    <div id="info-display">
        <button id="togglePhaseDisplayButton" class="control-button info">Toggle Info</button>
        <div id="phase-value"></div>
    </div>

    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.157.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/", "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@21.0.0/dist/tween.esm.js" } }</script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import TWEEN from '@tweenjs/tween.js';

        // --- GLOBAL STATE & PARAMETERS ---
        const waveParams = {
            points: 1000, length: 20, amplitudeY: 3, frequencyY: 0.5,
            amplitudeZ: 3, frequencyZ: 0.5, phaseZ: Math.PI / 2
        };
        let waveGroup, isTranslating, isRotating;
        let isHelixVisible = true;

        // Get references to all UI elements
        const translateButton = document.getElementById('translateButton');
        const rotateButton = document.getElementById('rotateButton');
        const toggleHelixButton = document.getElementById('toggleHelixButton');
        const togglePhaseDisplayButton = document.getElementById('togglePhaseDisplayButton');
        const phaseValueElement = document.getElementById('phase-value');

        // 1. SCENE SETUP (Unchanged)
        const canvasContainer = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 25);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        canvasContainer.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        const clock = new THREE.Clock();

        // 2. HELPER FUNCTIONS
        function createSineWaveGeometry(params) { /* ... unchanged ... */ const { points, length, amplitudeY, frequencyY, amplitudeZ, frequencyZ, phaseZ } = params; const positions = []; const step = length / points; for (let i = 0; i < points; i++) { const x = i * step - length / 2; const y = amplitudeY * Math.sin(x * frequencyY); const z = amplitudeZ * Math.sin(x * frequencyZ + phaseZ); positions.push(x, y, z); } const geometry = new THREE.BufferGeometry(); geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); geometry.userData.params = params; return geometry; }
        function createWaveSystem() { /* ... unchanged ... */ const group = new THREE.Group(); const mainWaveGeom = createSineWaveGeometry(waveParams); const sineWave = new THREE.Line(mainWaveGeom, new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 3 })); sineWave.name = 'mainWave'; const projectionXYGeom = new THREE.BufferGeometry(); projectionXYGeom.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(waveParams.points * 3), 3)); const projectionXY = new THREE.Line(projectionXYGeom, new THREE.LineBasicMaterial({ color: 0xffff00 })); projectionXY.name = 'projectionXY'; const projectionXZGeom = new THREE.BufferGeometry(); projectionXZGeom.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(waveParams.points * 3), 3)); const projectionXZ = new THREE.Line(projectionXZGeom, new THREE.LineBasicMaterial({ color: 0xff00ff })); projectionXZ.name = 'projectionXZ'; const gridSizeXZ = Math.max(waveParams.length, waveParams.amplitudeZ * 2); const gridSizeXY = Math.max(waveParams.length, waveParams.amplitudeY * 2); const gridDivisions = 10; const gridXZ = new THREE.GridHelper(gridSizeXZ, gridDivisions, 0x888888, 0x444444); const gridXY = new THREE.GridHelper(gridSizeXY, gridDivisions, 0x888888, 0x444444); gridXY.rotation.x = Math.PI / 2; const visiblePointsCount = 400, startPointIndex = 300; mainWaveGeom.setDrawRange(startPointIndex, visiblePointsCount); projectionXYGeom.setDrawRange(startPointIndex, visiblePointsCount); projectionXZGeom.setDrawRange(startPointIndex, visiblePointsCount); group.add(sineWave, projectionXY, projectionXZ, gridXZ, gridXY); return group; }
        function setButtonsDisabled(disabled) { translateButton.disabled = disabled; rotateButton.disabled = disabled; }
        function triggerTranslateAnimation() { if (isTranslating || isRotating) return; isTranslating = true; setButtonsDisabled(true); const targetX = waveGroup.position.x === 10 ? -10 : 10; new TWEEN.Tween(waveGroup.position).to({ x: targetX }, 2500).easing(TWEEN.Easing.Cubic.InOut).onComplete(() => { isTranslating = false; setButtonsDisabled(false); }).start(); }
        function toggleHelixVisibility() { isHelixVisible = !isHelixVisible; if (waveGroup) { const helix = waveGroup.getObjectByName('mainWave'); if (helix) helix.visible = isHelixVisible; } }
        function togglePhaseDisplay() { phaseValueElement.style.display = phaseValueElement.style.display === 'none' ? 'block' : 'none'; }
        
        // --- REFACTORED ROTATION ANIMATION ---
        function triggerRotationAnimation() {
            if (isTranslating || isRotating) return;
            isRotating = true;
            setButtonsDisabled(true);

            const projectionXZ = waveGroup.getObjectByName('projectionXZ');
            if (!projectionXZ) {
                console.error("XZ projection not found!");
                isRotating = false; setButtonsDisabled(false);
                return;
            }

            const rotateUp = new TWEEN.Tween(projectionXZ.rotation)
                .to({ x: Math.PI / 2 }, 1500) // Rotate XZ plane to align with XY
                .easing(TWEEN.Easing.Cubic.InOut);

            const phaseShift = new TWEEN.Tween(waveParams)
                .to({ phaseZ: 0 }, 2000)
                .easing(TWEEN.Easing.Cubic.InOut)
                .yoyo(true).repeat(1);
            
            const rotateDown = new TWEEN.Tween(projectionXZ.rotation)
                .to({ x: 0 }, 1500) // Rotate back to original XZ plane
                .easing(TWEEN.Easing.Cubic.InOut)
                .onComplete(() => {
                    isRotating = false;
                    setButtonsDisabled(false);
                });
            
            rotateUp.chain(phaseShift);
            phaseShift.chain(rotateDown);
            rotateUp.start();
        }

        // 3. INITIALIZATION
        function init() {
            waveGroup = createWaveSystem();
            scene.add(waveGroup);
            
            translateButton.addEventListener('click', triggerTranslateAnimation);
            rotateButton.addEventListener('click', triggerRotationAnimation);
            toggleHelixButton.addEventListener('click', toggleHelixVisibility);
            togglePhaseDisplayButton.addEventListener('click', togglePhaseDisplay);
            
            animate();
        }

        // 4. MAIN LOOP
        function animate() {
            requestAnimationFrame(animate);
            // Robust resize logic
            const { clientWidth, clientHeight } = canvasContainer; const canvas = renderer.domElement; const needResize = canvas.width !== clientWidth || canvas.height !== clientHeight; if (needResize) { renderer.setSize(clientWidth, clientHeight, false); camera.aspect = clientWidth / clientHeight; camera.updateProjectionMatrix(); }
            
            const elapsedTime = clock.getElapsedTime();
            TWEEN.update();
            controls.update();

            // Update PhaseZ display text on every frame
            phaseValueElement.textContent = `phaseZ: ${waveParams.phaseZ.toFixed(3)}`;

            // Update wave vertices
            const sineWave = waveGroup.getObjectByName('mainWave'); const projectionXY = waveGroup.getObjectByName('projectionXY'); const projectionXZ = waveGroup.getObjectByName('projectionXZ'); const params = sineWave.geometry.userData.params;
            for (let i = 0; i < params.points; i++) { const i3 = i * 3; const x = (i * (params.length / params.points)) - params.length / 2; const y = params.amplitudeY * Math.sin(x * params.frequencyY + elapsedTime); const z = params.amplitudeZ * Math.sin(x * params.frequencyZ + params.phaseZ + elapsedTime); const mainPositions = sineWave.geometry.attributes.position.array; mainPositions[i3] = x; mainPositions[i3 + 1] = y; mainPositions[i3 + 2] = z; const xyPositions = projectionXY.geometry.attributes.position.array; xyPositions[i3] = x; xyPositions[i3 + 1] = y; xyPositions[i3 + 2] = 0; const xzPositions = projectionXZ.geometry.attributes.position.array; xzPositions[i3] = x; xzPositions[i3 + 1] = 0; xzPositions[i3 + 2] = z; }
            sineWave.geometry.attributes.position.needsUpdate = true; projectionXY.geometry.attributes.position.needsUpdate = true; projectionXZ.geometry.attributes.position.needsUpdate = true;
            
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>