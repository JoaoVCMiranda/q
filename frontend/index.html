<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Cinematic Wave Animation</title>
    <style>
        body { margin: 0; background-color: #111; color: white; }
        canvas { display: block; }
        #controls { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 10; }
        #runButton { padding: 12px 24px; font-size: 16px; cursor: pointer; background-color: #00ff88; border: none; border-radius: 5px; color: #111; font-weight: bold; }
        #runButton:disabled { background-color: #555; cursor: not-allowed; }
    </style>
</head>
<body>
    <div id="controls">
        <button id="runButton">Run Animation</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/",
                "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@21.0.0/dist/tween.esm.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import TWEEN from '@tweenjs/tween.js';

        // --- GLOBAL STATE & PARAMETERS ---
        const waveParams = {
            points: 1000, length: 20,
            amplitudeY: 3, frequencyY: 0.5,
            amplitudeZ: 3, frequencyZ: 0.5,
            phaseZ: Math.PI / 3
        };
        const cameraStartPos = new THREE.Vector3(0, 8, 25);
        const cameraEndPos = new THREE.Vector3(15, 6, 20);

        let activeWaveGroup = null;
        let isAnimationRunning = false;
        const runButton = document.getElementById('runButton');

        // 1. SCENE SETUP
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.copy(cameraStartPos); // Set initial position
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        const clock = new THREE.Clock();

        // 2. HELPER: GEOMETRY GENERATOR (Unchanged)
        function createSineWaveGeometry(params) { /* ... same as before ... */ 
            const { points, length, amplitudeY, frequencyY, amplitudeZ, frequencyZ, phaseZ } = params;
            const positions = []; const step = length / points;
            for (let i = 0; i < points; i++) {
                const x = i * step - length / 2; const y = amplitudeY * Math.sin(x * frequencyY);
                const z = amplitudeZ * Math.sin(x * frequencyZ + phaseZ); positions.push(x, y, z);
            }
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.userData.params = params; return geometry;
        }

        // 3. REFACTORED CREATION & DISPOSAL LOGIC
        function createWaveSystem() {
            const group = new THREE.Group();
            
            // --- Create components (using global waveParams) ---
            const mainWaveGeom = createSineWaveGeometry(waveParams);
            const sineWave = new THREE.Line(mainWaveGeom, new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 3 }));
            sineWave.name = 'mainWave';
            // ... (other projections created similarly) ...
            const projectionXYGeom = new THREE.BufferGeometry(); projectionXYGeom.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(waveParams.points * 3), 3));
            const projectionXY = new THREE.Line(projectionXYGeom, new THREE.LineBasicMaterial({ color: 0xffff00 }));
            projectionXY.name = 'projectionXY';
            const projectionXZGeom = new THREE.BufferGeometry(); projectionXZGeom.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(waveParams.points * 3), 3));
            const projectionXZ = new THREE.Line(projectionXZGeom, new THREE.LineBasicMaterial({ color: 0xff00ff }));
            projectionXZ.name = 'projectionXZ';


            // --- NEW: DYNAMIC GRIDS ---
            // Ensure grid is large enough for both length and amplitude
            const gridSizeXZ = Math.max(waveParams.length, waveParams.amplitudeZ * 2);
            const gridSizeXY = Math.max(waveParams.length, waveParams.amplitudeY * 2);
            const gridDivisions = 10;
            const gridXZ = new THREE.GridHelper(gridSizeXZ, gridDivisions, 0x888888, 0x444444);
            const gridXY = new THREE.GridHelper(gridSizeXY, gridDivisions, 0x888888, 0x444444);
            gridXY.rotation.x = Math.PI / 2;
            
            // Set draw range
            const visiblePointsCount = 400, startPointIndex = 300;
            mainWaveGeom.setDrawRange(startPointIndex, visiblePointsCount);
            projectionXYGeom.setDrawRange(startPointIndex, visiblePointsCount);
            projectionXZGeom.setDrawRange(startPointIndex, visiblePointsCount);

            group.add(sineWave, projectionXY, projectionXZ, gridXZ, gridXY);
            return group;
        }

        function disposeWaveSystem(group) {
             if (!group) return;
            group.traverse(object => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) object.material.dispose();
            });
            scene.remove(group);
        }

        // 4. THE MAIN CONTROLLABLE FUNCTION
        function runWaveAnimation() {
            if (isAnimationRunning) return;
            isAnimationRunning = true;
            runButton.disabled = true;

            // --- Reset camera to start position before animating ---
            camera.position.copy(cameraStartPos);

            // 1. Create System
            const waveSystem = createWaveSystem();
            activeWaveGroup = waveSystem;
            waveSystem.position.x = -10;
            scene.add(waveSystem);

            // 2. Animate Group
            const duration = 4000;
            new TWEEN.Tween(waveSystem.position)
                .to({ x: 10 }, duration)
                .easing(TWEEN.Easing.Cubic.InOut)
                .onComplete(() => {
                    // 3. Delete System
                    disposeWaveSystem(waveSystem);
                    activeWaveGroup = null;
                    isAnimationRunning = false;
                    runButton.disabled = false;
                })
                .start();
            
            // --- NEW: Animate Camera in parallel ---
            new TWEEN.Tween(camera.position)
                .to({ x: cameraEndPos.x, y: cameraEndPos.y, z: cameraEndPos.z }, duration)
                .easing(TWEEN.Easing.Cubic.InOut)
                .start();
        }
        runButton.addEventListener('click', runWaveAnimation);

        // 5. THE MAIN ANIMATION LOOP
        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            
            TWEEN.update(); // Update both TWEENs (group and camera)

            if (activeWaveGroup) {
                // --- NEW: Always frame the animation ---
                // This makes the camera track the group's center point.
                camera.lookAt(activeWaveGroup.position);
                
                // Update the wave vertices (internal animation)
                // ... same logic as before to update vertex positions ...
                const sineWave = activeWaveGroup.getObjectByName('mainWave');
                const projectionXY = activeWaveGroup.getObjectByName('projectionXY');
                const projectionXZ = activeWaveGroup.getObjectByName('projectionXZ');
                if (sineWave && projectionXY && projectionXZ) {
                    const mainPositions = sineWave.geometry.attributes.position.array;
                    const xyPositions = projectionXY.geometry.attributes.position.array;
                    const xzPositions = projectionXZ.geometry.attributes.position.array;
                    const params = sineWave.geometry.userData.params;
                    for (let i = 0; i < params.points; i++) {
                        const i3 = i * 3; const x = (i * (params.length / params.points)) - params.length / 2;
                        const y = params.amplitudeY * Math.sin(x * params.frequencyY + elapsedTime);
                        const z = params.amplitudeZ * Math.sin(x * params.frequencyZ + params.phaseZ + elapsedTime);
                        mainPositions[i3] = x; mainPositions[i3 + 1] = y; mainPositions[i3 + 2] = z;
                        xyPositions[i3] = x; xyPositions[i3 + 1] = y; xyPositions[i3 + 2] = 0;
                        xzPositions[i3] = x; xzPositions[i3 + 1] = 0; xzPositions[i3 + 2] = z;
                    }
                    sineWave.geometry.attributes.position.needsUpdate = true;
                    projectionXY.geometry.attributes.position.needsUpdate = true;
                    projectionXZ.geometry.attributes.position.needsUpdate = true;
                }
            }

            // Let OrbitControls update if user is not animating,
            // but the lookAt will override it during the animation.
            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>