<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Ephemeral Animation</title>
    <style>
        body { margin: 0; background-color: #111; color: white; }
        canvas { display: block; }
        #controls { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 10; }
        #runButton { padding: 12px 24px; font-size: 16px; cursor: pointer; background-color: #00ff88; border: none; border-radius: 5px; color: #111; font-weight: bold; }
        #runButton:disabled { background-color: #555; cursor: not-allowed; }
    </style>
</head>
<body>
    <div id="controls">
        <button id="runButton">Run Animation</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/",
                "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@21.0.0/dist/tween.esm.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import TWEEN from '@tweenjs/tween.js';

        // --- GLOBAL STATE ---
        let activeWaveGroup = null;
        let isAnimationRunning = false;
        const runButton = document.getElementById('runButton');

        // 1. SCENE SETUP
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 25);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        const clock = new THREE.Clock();

        // 2. HELPER: GEOMETRY GENERATOR (Unchanged)
        function createSineWaveGeometry(params) { /* ... same as before ... */ 
            const { points = 500, length = 20, amplitudeY = 2, frequencyY = 2, amplitudeZ = 2, frequencyZ = 2, phaseZ = Math.PI / 2 } = params;
            const positions = []; const step = length / points;
            for (let i = 0; i < points; i++) {
                const x = i * step - length / 2; const y = amplitudeY * Math.sin(x * frequencyY);
                const z = amplitudeZ * Math.sin(x * frequencyZ + phaseZ); positions.push(x, y, z);
            }
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.userData.params = params; return geometry;
        }

        // 3. REFACTORED CREATION & DISPOSAL LOGIC
        // =============================================

        /** Creates the entire wave system and returns it as a group. */
        function createWaveSystem() {
            const group = new THREE.Group();
            const waveParams = { points: 1000, length: 20, amplitudeY: 3, frequencyY: 0.5, amplitudeZ: 3, frequencyZ: 0.5, phaseZ: Math.PI / 2 };
            
            // --- Create components and add names for easy access later ---
            const mainWaveGeom = createSineWaveGeometry(waveParams);
            const sineWave = new THREE.Line(mainWaveGeom, new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 3 }));
            sineWave.name = 'mainWave';
            
            const projectionXYGeom = new THREE.BufferGeometry(); projectionXYGeom.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(waveParams.points * 3), 3));
            const projectionXY = new THREE.Line(projectionXYGeom, new THREE.LineBasicMaterial({ color: 0xffff00 }));
            projectionXY.name = 'projectionXY';

            const projectionXZGeom = new THREE.BufferGeometry(); projectionXZGeom.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(waveParams.points * 3), 3));
            const projectionXZ = new THREE.Line(projectionXZGeom, new THREE.LineBasicMaterial({ color: 0xff00ff }));
            projectionXZ.name = 'projectionXZ';

            const gridXZ = new THREE.GridHelper(waveParams.length, 10, 0x888888, 0x444444);
            const gridXY = new THREE.GridHelper(waveParams.length, 10, 0x888888, 0x444444); gridXY.rotation.x = Math.PI / 2;

            // Set draw range
            const visiblePointsCount = 400, startPointIndex = 300;
            mainWaveGeom.setDrawRange(startPointIndex, visiblePointsCount);
            projectionXYGeom.setDrawRange(startPointIndex, visiblePointsCount);
            projectionXZGeom.setDrawRange(startPointIndex, visiblePointsCount);

            group.add(sineWave, projectionXY, projectionXZ, gridXZ, gridXY);
            return group;
        }

        /** Properly disposes of a wave system to prevent memory leaks. */
        function disposeWaveSystem(group) {
            if (!group) return;
            group.traverse(object => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) object.material.dispose();
            });
            scene.remove(group);
        }

        // 4. THE MAIN CONTROLLABLE FUNCTION
        // =============================================
        function runWaveAnimation() {
            if (isAnimationRunning) return; // Prevent multiple executions

            isAnimationRunning = true;
            runButton.disabled = true;

            // 1. Create
            const waveSystem = createWaveSystem();
            activeWaveGroup = waveSystem; // Make it accessible to the animate loop
            waveSystem.position.x = -10;
            scene.add(waveSystem);

            // 2. Animate
            new TWEEN.Tween(waveSystem.position)
                .to({ x: 10 }, 4000) // 4 second duration
                .easing(TWEEN.Easing.Cubic.InOut)
                .onComplete(() => {
                    // 3. Delete
                    disposeWaveSystem(waveSystem);
                    activeWaveGroup = null;
                    isAnimationRunning = false;
                    runButton.disabled = false;
                })
                .start();
        }

        runButton.addEventListener('click', runWaveAnimation);

        // 5. THE MAIN ANIMATION LOOP
        // =============================================
        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            
            TWEEN.update(); // Update the TWEEN engine

            // Only perform vertex updates if a wave group exists
            if (activeWaveGroup) {
                const sineWave = activeWaveGroup.getObjectByName('mainWave');
                const projectionXY = activeWaveGroup.getObjectByName('projectionXY');
                const projectionXZ = activeWaveGroup.getObjectByName('projectionXZ');
                
                if (sineWave && projectionXY && projectionXZ) {
                    const mainPositions = sineWave.geometry.attributes.position.array;
                    const xyPositions = projectionXY.geometry.attributes.position.array;
                    const xzPositions = projectionXZ.geometry.attributes.position.array;
                    const params = sineWave.geometry.userData.params;
                    for (let i = 0; i < params.points; i++) {
                        const i3 = i * 3; const x = (i * (params.length / params.points)) - params.length / 2;
                        const y = params.amplitudeY * Math.sin(x * params.frequencyY + elapsedTime);
                        const z = params.amplitudeZ * Math.sin(x * params.frequencyZ + params.phaseZ + elapsedTime);
                        mainPositions[i3] = x; mainPositions[i3 + 1] = y; mainPositions[i3 + 2] = z;
                        xyPositions[i3] = x; xyPositions[i3 + 1] = y; xyPositions[i3 + 2] = 0;
                        xzPositions[i3] = x; xzPositions[i3 + 1] = 0; xzPositions[i3 + 2] = z;
                    }
                    sineWave.geometry.attributes.position.needsUpdate = true;
                    projectionXY.geometry.attributes.position.needsUpdate = true;
                    projectionXZ.geometry.attributes.position.needsUpdate = true;
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>