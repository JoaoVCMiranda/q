<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Debug View with Toggles</title>
    <style>
        /* Stripped-down CSS for a full-screen debug view */
        body {
            margin: 0;
            background-color: #111;
            overflow: hidden; /* Prevent scrollbars */
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #button-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            gap: 15px;
        }

        /* Re-using the same button styles */
        .control-button {
            padding: 12px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .control-button.primary { background-color: #008cff; color: white; }
        .control-button.secondary { background-color: #00ff88; color: #111; }
        /* NEW STYLE for the toggle button */
        .control-button.tertiary { background-color: #ffaa00; color: #111; }
        .control-button:hover:not(:disabled) { filter: brightness(1.1); }
        .control-button:disabled { background-color: #555; color: #999; cursor: not-allowed; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="button-container">
        <button id="translateButton" class="control-button primary">Translate Wave</button>
        <button id="rotateButton" class="control-button secondary">Rotate & Phase Shift</button>
        <!-- NEW BUTTON -->
        <button id="toggleHelixButton" class="control-button tertiary">Toggle 3D Helix</button>
    </div>

    <!-- The entire JavaScript section is UNCHANGED from the previous correct version -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/",
                "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@21.0.0/dist/tween.esm.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import TWEEN from '@tweenjs/tween.js';

        // --- GLOBAL STATE & PARAMETERS ---
        const waveParams = {
            points: 1000, length: 20, amplitudeY: 3, frequencyY: 0.5,
            amplitudeZ: 3, frequencyZ: 0.5, phaseZ: Math.PI / 2
        };
        let waveGroup, isTranslating, isRotating;
        let isHelixVisible = true; // NEW STATE VARIABLE

        // Get references to all buttons
        const translateButton = document.getElementById('translateButton');
        const rotateButton = document.getElementById('rotateButton');
        const toggleHelixButton = document.getElementById('toggleHelixButton');

        // 1. SCENE SETUP (Unchanged)
        const canvasContainer = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 25);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        canvasContainer.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        const clock = new THREE.Clock();

        // 2. HELPER FUNCTIONS (Most are unchanged)
        function createSineWaveGeometry(params) { /* ... unchanged ... */ const { points, length, amplitudeY, frequencyY, amplitudeZ, frequencyZ, phaseZ } = params; const positions = []; const step = length / points; for (let i = 0; i < points; i++) { const x = i * step - length / 2; const y = amplitudeY * Math.sin(x * frequencyY); const z = amplitudeZ * Math.sin(x * frequencyZ + phaseZ); positions.push(x, y, z); } const geometry = new THREE.BufferGeometry(); geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); geometry.userData.params = params; return geometry; }
        function createWaveSystem() { /* ... unchanged ... */ const group = new THREE.Group(); const mainWaveGeom = createSineWaveGeometry(waveParams); const sineWave = new THREE.Line(mainWaveGeom, new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 3 })); sineWave.name = 'mainWave'; const projectionXYGeom = new THREE.BufferGeometry(); projectionXYGeom.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(waveParams.points * 3), 3)); const projectionXY = new THREE.Line(projectionXYGeom, new THREE.LineBasicMaterial({ color: 0xffff00 })); projectionXY.name = 'projectionXY'; const projectionXZGeom = new THREE.BufferGeometry(); projectionXZGeom.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(waveParams.points * 3), 3)); const projectionXZ = new THREE.Line(projectionXZGeom, new THREE.LineBasicMaterial({ color: 0xff00ff })); projectionXZ.name = 'projectionXZ'; const gridSizeXZ = Math.max(waveParams.length, waveParams.amplitudeZ * 2); const gridSizeXY = Math.max(waveParams.length, waveParams.amplitudeY * 2); const gridDivisions = 10; const gridXZ = new THREE.GridHelper(gridSizeXZ, gridDivisions, 0x888888, 0x444444); const gridXY = new THREE.GridHelper(gridSizeXY, gridDivisions, 0x888888, 0x444444); gridXY.rotation.x = Math.PI / 2; const visiblePointsCount = 400, startPointIndex = 300; mainWaveGeom.setDrawRange(startPointIndex, visiblePointsCount); projectionXYGeom.setDrawRange(startPointIndex, visiblePointsCount); projectionXZGeom.setDrawRange(startPointIndex, visiblePointsCount); group.add(sineWave, projectionXY, projectionXZ, gridXZ, gridXY); return group; }
        function setButtonsDisabled(disabled) { translateButton.disabled = disabled; rotateButton.disabled = disabled; }
        function triggerTranslateAnimation() { /* ... unchanged ... */ if (isTranslating || isRotating) return; isTranslating = true; setButtonsDisabled(true); const targetX = waveGroup.position.x === 10 ? -10 : 10; new TWEEN.Tween(waveGroup.position).to({ x: targetX }, 2500).easing(TWEEN.Easing.Cubic.InOut).onComplete(() => { isTranslating = false; setButtonsDisabled(false); }).start(); }
        function triggerRotationAnimation() { /* ... unchanged ... */ if (isTranslating || isRotating) return; isRotating = true; setButtonsDisabled(true); const rotateForward = new TWEEN.Tween(waveGroup.rotation).to({ x: -Math.PI / 2 }, 1500).easing(TWEEN.Easing.Cubic.InOut); const phaseShift = new TWEEN.Tween(waveParams).to({ phaseZ: 0 }, 2000).easing(TWEEN.Easing.Cubic.InOut).yoyo(true).repeat(1); const rotateBack = new TWEEN.Tween(waveGroup.rotation).to({ x: 0 }, 1500).easing(TWEEN.Easing.Cubic.InOut).onComplete(() => { isRotating = false; setButtonsDisabled(false); }); rotateForward.chain(phaseShift); phaseShift.chain(rotateBack); rotateForward.start(); }

        // --- NEW TOGGLE FUNCTION ---
        function toggleHelixVisibility() {
            // This action is instant, so we don't need to disable other buttons.
            isHelixVisible = !isHelixVisible; // Flip the boolean state

            if (waveGroup) {
                const helix = waveGroup.getObjectByName('mainWave');
                if (helix) {
                    helix.visible = isHelixVisible;
                }
            }
        }

        // 3. INITIALIZATION
        function init() {
            waveGroup = createWaveSystem();
            scene.add(waveGroup);
            
            // Add all event listeners
            translateButton.addEventListener('click', triggerTranslateAnimation);
            rotateButton.addEventListener('click', triggerRotationAnimation);
            toggleHelixButton.addEventListener('click', toggleHelixVisibility); // NEW
            
            animate();
        }

        // 4. MAIN LOOP (Unchanged)
        function animate() {
            requestAnimationFrame(animate);
            // Robust resize logic...
            const { clientWidth, clientHeight } = canvasContainer; const canvas = renderer.domElement; const needResize = canvas.width !== clientWidth || canvas.height !== clientHeight; if (needResize) { renderer.setSize(clientWidth, clientHeight, false); camera.aspect = clientWidth / clientHeight; camera.updateProjectionMatrix(); }
            // Update animations and controls...
            const elapsedTime = clock.getElapsedTime(); TWEEN.update(); controls.update();
            // Update wave vertices...
            const sineWave = waveGroup.getObjectByName('mainWave'); const projectionXY = waveGroup.getObjectByName('projectionXY'); const projectionXZ = waveGroup.getObjectByName('projectionXZ'); const params = sineWave.geometry.userData.params;
            for (let i = 0; i < params.points; i++) { const i3 = i * 3; const x = (i * (params.length / params.points)) - params.length / 2; const y = params.amplitudeY * Math.sin(x * params.frequencyY + elapsedTime); const z = params.amplitudeZ * Math.sin(x * params.frequencyZ + params.phaseZ + elapsedTime); const mainPositions = sineWave.geometry.attributes.position.array; mainPositions[i3] = x; mainPositions[i3 + 1] = y; mainPositions[i3 + 2] = z; const xyPositions = projectionXY.geometry.attributes.position.array; xyPositions[i3] = x; xyPositions[i3 + 1] = y; xyPositions[i3 + 2] = 0; const xzPositions = projectionXZ.geometry.attributes.position.array; xzPositions[i3] = x; xzPositions[i3 + 1] = 0; xzPositions[i3 + 2] = z; }
            sineWave.geometry.attributes.position.needsUpdate = true; projectionXY.geometry.attributes.position.needsUpdate = true; projectionXZ.geometry.attributes.position.needsUpdate = true;
            
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>